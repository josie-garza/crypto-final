from Crypto.PublicKey import RSA
from Crypto.PublicKey import ECC
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import DSS
from Crypto.Hash import SHA3_256
from Crypto.Util.Padding import pad, unpad


CURRENT_VERSION = 0


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                            Encryption & Decryption
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# IN: plaintext (bytestring), pub_key (RSA type)
# OUT: ciphertext (bytestring)
# DESC: Encrypts the plaintext with PKCS#1 OAEP (v1.5). Raises ValueError if the message is too long (>190 bytes)
# NOTE: You should call load_RSA_key with the RSA pubkey file and pass its result as the second parameter
def encrypt_with_RSA(plaintext, pub_key):
    cipher = PKCS1_OAEP.new(pub_key)
    try:
        return cipher.encrypt(plaintext)
    except ValueError:
        print("Encryption ValueError: plaintext is too long (190 byte max)\nPlaintext: " + plaintext.decode('ascii'))
        sys.exit(1)


# IN: ciphertext (bytestring), priv_key (RSA type)
# OUT: plaintext (bytestring)
# DESC: Decrypts the plaintext with PKCS#1 OAEP (v1.5).
#       Raises ValueError if the ciphertext has the wrong length or if decryption fails the integrity check.
#       Raises TypeError if the RSA key has no private half (i.e. you are trying to decrypt using a pub key)
# NOTE: You should call load_RSA_key with the RSA keypair file and pass its result as the second parameter
def decrypt_with_RSA(ciphertext, key_pair):
    cipher = PKCS1_OAEP.new(keypair)
    try:
        return cipher.decrypt(ciphertext)
    except ValueError:
        print("Decryption ValueError: either ciphertext has the wrong length or decryption failed the integrity check. Ensure you are using the correct key!")
        sys.exit(1)
    except TypeError:
        print("Decryption TypeError: the RSA key has no private half - you are trying to decrypt with a public key!")
        sys.exit(1)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                             Digital Signatures
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# IN: priv_key (ECC type), message (bytestring)
# OUT: signature of message (bytestring)
# DESC: Returns the ECDSA signature of message generated by using priv_key
# NOTE: You should call load_ECC_key() and pass its result as priv_key
def gen_signature(priv_key, msg):
    signer = DSS.new(priv_key, 'fips-186-3')
    h = SHA3_256.new(msg)
    return signer.sign(h)


# IN: sig (ECDSA signature generated by gen_signature)
# OUT: True if the signature is valid, False otherwise
def verify_signature_helper(sig, msg, pub_key):
    verifier = DSS.new(pub_key, 'fips-186-3')
    h = SHA3_256.new(msg)
    try:
        verifier.verify(h, sig)
        return True
    except ValueError:
        return False


# IN: msg (bytestring), pub_key (ECC type)
# OUT: True if the message's signature is valid, False otherwise
# DESC: parses the message using parse_received_msg and then verifies the signature
def verify_signature(msg, pub_key):
    parsed = parse_received_msg(msg)
    sig = parsed[4]
    signed = parsed[0] + parsed[1] + parsed[2]
    return verify_signature_helper(sig, signed, pub_key)


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                                    Misc
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# IN: cmd (string)
# OUT: returns true if the command is a valid one, and false otherwise
def is_valid_cmd(cmd):
    return cmd.upper() in ["LGN", "MKD", "RMD", "GWD", "CWD", "LST", "UPL", "DNL", "RMF", "LGO"]


# IN: N/A
# OUT: version (Int)
# DESC: returns the current version number
def get_ver_num():
    return CURRENT_VERSION


# IN: command line (string)
# OUT: [the command (string), additional_info (string)]
# DESC: takes a command line as a string and outputs the command and additional_info (if applicable)
# NOTE: returns None if the command is invalid. This can be used to display an error to the user
def parse_cmd_line(cmd_line):
    components = cmd_line.split()
    if not is_valid_cmd(components[0]):
        print("Error! Command '" + components[0] + "' not valid.")
        return None
    else:
        if (len(components) > 1):
            return components[:2]
        else:
            return components


# IN: msg (bytestring)
# OUT: [ver (plaintext), enc_payload (ciphertext), auth_tag (plaintext), this_file (ciphertext), sig (plaintext)]
# DESC: Takes a received message and parses it into its components. If no file is included, auth_tag and this_file
#       will be empty strings.
def parse_received_msg(msg):
    ver = msg[:2]
    rest_of_msg = msg[2:]

    enc_payload = rest_of_msg[:256]
    rest_of_msg = rest_of_msg[256:]

    sig = rest_of_msg[-64:]
    rest_of_msg = rest_of_msg[:-64]

    auth_tag = ''
    this_file = ''

    # rest_of_msg is the empty string, there was no file
    if (len(rest_of_msg) > 0):
        auth_tag = rest_of_msg[:16]
        rest_of_msg = rest_of_msg[16:]

        this_file = rest_of_msg

    return [ver, enc_payload, auth_tag, this_file, sig]


# IN: ver (bytestrign), seq_num (bytestring), cmd (bytestring), recipient_pub_RSA_key (RSA type),
#     sender_priv_ECC_key (ECC type), add_info (bytestring, optional), enc_file (bytestring, optional),
#     file_auth (bytestring, optional)
# OUT: the resulting message (bytestring)
# DESC: Takes all of the relevant information necessary for constructing a message, encrypts the payload,
#      digitally signs the important information, and smashes it all together
def construct_msg(ver, seq_num, cmd, recipient_pub_RSA_key, sender_priv_ECC_key,
                  add_info='', enc_file=b'', file_auth=b''):
    # converting inputs into bytes
    ver = ver.to_bytes(length=2, byteorder='big')
    seq_num = seq_num.to_bytes(length=2, byteorder='big')
    cmd = cmd.encode('ascii')
    add_info = add_info.encode('ascii')

    my_msg = b''
    my_msg += ver
    my_msg += encrypt_with_RSA(seq_num + cmd + add_info, recipient_pub_RSA_key)
    my_msg += file_auth

    sig = gen_signature(sender_priv_ECC_key, my_msg)

    my_msg += enc_file
    my_msg += sig

    return my_msg


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                             Key Storage & Loading
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# IN: key (RSA type), privkeyfile (string)
# OUT: N/A
# DESC: Writes the passed keypair to the passed file.
# NOTE: key can either be a keypair or a public key
def save_RSA_key(key, keyfile):
    f = open(keyfile, 'wb')
    f.write(key.export_key(format='PEM'))
    f.close()

# IN: key (ECC type), privkeyfile (string)
# OUT: N/A
# DESC: Writes the passed keypair to the passed file.
# NOTE: key can either be a keypair or a public key
def save_ECC_key(key, keyfile):
    f = open(keyfile, 'wt')
    f.write(key.export_key(format='PEM'))
    f.close()


# IN: keyfile (string)
# OUT: key (RSA type)
# DESC: Attempts to load a key from keyfile. Prints error if unable to do so.
# NOTE: Key can either be a public key or key pair
def load_RSA_key(keyfile):
    f = open(keyfile, 'rb')
    keystr = f.read()
    f.close()
    try:
        return RSA.import_key(keystr)
    except ValueError:
        print('ValueError: Cannot import RSA key from file ' + keyfile)
        sys.exit(1)


# IN: keyfile (string)
# OUT: key (ECC type)
# DESC: Attempts to load a key from keyfile. Prints error if unable to do so.
# NOTE: Key can either be a public key or private key
def load_ECC_key(keyfile):
    f = open(keyfile, 'rb')
    keystr = f.read()
    f.close()

    try:
        return ECC.import_key(keystr)
    except ValueError:
        print('ValueError: Cannot import ECC key from file ' + keyfile)
        sys.exit(1)

def generateTestingKeys():
    print('Generating a new 2048-bit RSA key pair for client...')
    keypair = RSA.generate(2048)
    save_RSA_key(keypair.publickey(), './server/keys/789/pubenc.pem')
    save_RSA_key(keypair, 'privenc.pem')
    print('Done')

    print('Generating a new 2048-bit RSA key pair for server...')
    keypair = RSA.generate(2048)
    save_RSA_key(keypair.publickey(), './server/keys/server/pubenc.pem')
    save_RSA_key(keypair, './server/keys/server/privenc.pem')
    print('Done')

    print('Generating a new 2048-bit ECC key pair for client...')
    ECC_priv_key = ECC.generate(curve='P-256')
    publickey = ECC_priv_key.public_key()
    save_ECC_key(publickey, './server/keys/789/pubsig.pem')
    save_ECC_key(ECC_priv_key, 'privsig.pem')
    print('Done')

    print('Generating a new 2048-bit ECC key pair for server...')
    ECC_priv_key = ECC.generate(curve='P-256')
    publickey = ECC_priv_key.public_key()
    save_ECC_key(publickey, './server/keys/server/pubsig.pem')
    save_ECC_key(ECC_priv_key, './server/keys/server/privsig.pem')
    print('Done')

# This is solely for testing purposes and will be removed before finalization
def main():
    # Basic signature generation and verification testing:
    #generateTestingKeys()
    my_msg_first = b'Hello, my name is Jack'
    my_msg_second = b'hehehe'

    ECC_priv_key = ECC.generate(curve='P-256')
    ECC_pub_key = ECC_priv_key.public_key()

    my_sig_first = gen_signature(ECC_priv_key, my_msg_first)
    my_sig_second = gen_signature(ECC_priv_key, my_msg_second)

    print("my_msg_first and my_sig_first: ", end="")
    if verify_signature_helper(my_sig_first, my_msg_first, ECC_pub_key):
        print("True")
    else:
        print("False")

    print("my_msg_second and my_sig_first: ", end="")
    if verify_signature_helper(my_sig_first, my_msg_second, ECC_pub_key):
        print("True")
    else:
        print("False")


    # Basic encryption and decryption testing:
    plaintext1 = b"Hello there!"
    plaintext2 = b"It's over Anakin! I have the high ground!"

    RSA_key_pair = RSA.generate(2048)
    RSA_pub_key = RSA_key_pair.publickey()

    ciphertext1 = encrypt_with_RSA(plaintext1, RSA_pub_key)
    ciphertext2 = encrypt_with_RSA(plaintext2, RSA_pub_key)

    print("plaintext1: ", end="")
    print(plaintext1)
    print("ciphertext1: ", end="")
    print(ciphertext1)

    print("plaintext2: ", end="")
    print(plaintext2)
    print("ciphertext2: ", end="")
    print(ciphertext2)

    print(len(ciphertext1))
    print(len(ciphertext2))


    print(parse_cmd_line("jhs myfile.txt"))
    print(parse_cmd_line("upl myfile.txt"))


if (__name__ == "__main__"):
    main()
